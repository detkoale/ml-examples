
# coding: utf-8

# #  `NumPy`: матрицы и операции над ними
# ---

# В этом ноутбуке из сторонних библиотек нам понадобится только `NumPy`. Для удобства импортируем ее под более коротким именем:

# In[1]:

import numpy as np


# ## 1. Создание матриц

# Приведем несколько способов создания матриц в `NumPy`.

# Самый простой способ — с помощью функции __`numpy.array(list, dtype=None, ...)`__.
# 
# В качестве первого аргумента ей надо передать итерируемый объект, элементами которого являются другие итерируемые объекты одинаковой длины и содержащие данные одинакового типа.
# 
# Второй аргумент является опциональным и определяет тип данных матрицы. Его можно не задавать, тогда тип данных будет определен из типа элементов первого аргумента. При задании этого параметра будет произведена попытка приведения типов.
# 
# Например, матрицу из списка списков целых чисел можно создать следующим образом:

# In[2]:

a = np.array([[1, 2, 3], [2, 5, 6], [6, 7, 4]])
print "Матрица:\n", a


# Второй способ создания — с помощью встроенных функций __`numpy.eye(N, M=None, ...)`__, __`numpy.zeros(shape, ...)`__, __`numpy.ones(shape, ...)`__.
# 
# Первая функция создает единичную матрицу размера $N \times M$; если $M$ не задан, то $M = N$. 
# 
# Вторая и третья функции создают матрицы, состоящие целиком из нулей или единиц соответственно. В качестве первого аргумента необходимо задать размерность массива — кортеж целых чисел. В двумерном случае это набор из двух чисел: количество строк и столбцов матрицы.
# 
# __Примеры:__

# In[3]:

b = np.eye(5)
print "Единичная матрица:\n", b


# In[4]:

c = np.ones((7, 5))
print "Матрица, состоящая из одних единиц:\n", c


# __Обратите внимание: размерность массива задается не двумя аргументами функции, а одним — кортежем!__ 
# 
# Вот так —  __`np.ones(7, 5)`__ — создать массив не получится, так как функции в качестве параметра `shape` передается `7`, а не кортеж `(7, 5)`.

# И, наконец, третий способ — с помощью функции __`numpy.arange([start, ]stop, [step, ], ...)`__, которая создает одномерный массив последовательных чисел из промежутка __`[start, stop)`__ с заданным шагом __`step`__, и _метода_ __`array.reshape(shape)`__. 
# 
# Параметр __`shape`__, как и в предыдущем примере, задает размерность матрицы (кортеж чисел). Логика работы метода ясна из следующего примера:

# In[5]:

v = np.arange(0, 24, 2)
print "Вектор-столбец:\n", v


# In[6]:

d = v.reshape((3, 4))
print "Матрица:\n", d


# Более подробно о том, как создавать массивы в `NumPy`, 
# см. [документацию](http://docs.scipy.org/doc/numpy-1.10.1/user/basics.creation.html).

# ## 2. Индексирование 

# Для получения элементов матрицы можно использовать несколько способов. Рассмотрим самые простые из них.

# Для удобства напомним, как выглядит матрица __d__:

# In[7]:

print "Матрица:\n", d


# Элемент на пересечении строки __`i`__ и столбца __`j`__ можно получить с помощью выражения __`array[i, j]`__. 
# 
# __Обратите внимание:__ строки и столбцы нумеруются с нуля!

# In[8]:

print "Второй элемент третьей строки матрицы:", d[2, 1]


# Из матрицы можно получать целые строки или столбцы с помощью выражений __`array[i, :]`__ или __`array[:, j]`__ соответственно:

# In[9]:

print "Вторая строка матрицы d:\n", d[1, :]
print "Четвертый столбец матрицы d:\n", d[:, 3]


# Еще один способ получения элементов — с помощью выражения __`array[list1, list2]`__, где __`list1`__, __`list2`__ — некоторые списки целых чисел. При такой адресации одновременно просматриваются оба списка и возвращаются элементы матрицы с соответствующими координатами. Следующий пример более понятно объясняет механизм работы такого индексирования:

# In[10]:

print "Элементы матрицы d с координатами (1, 2) и (0, 3):\n", d[[1, 0], [2, 3]]


# Более подробно о различных способах индексирования в массивах
# см. [документацию](http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html).

# ## 3. Векторы, вектор-строки и вектор-столбцы

# Следующие два способа задания массива кажутся одинаковыми: 

# In[11]:

a = np.array([1, 2, 3])
b = np.array([[1], [2], [3]])


# Однако, на самом деле, это задание одномерного массива (то есть _вектора_) и двумерного массива:

# In[12]:

print "Вектор:\n", a
print "Его размерность:\n", a.shape
print "Двумерный массив:\n", b
print "Его размерность:\n", b.shape


# __Обратите внимание:__ _вектор_ (одномерный массив) и _вектор-столбец_ или _вектор-строка_ (двумерные массивы) являются различными объектами в `NumPy`, хотя математически задают один и тот же объект. В случае одномерного массива кортеж __`shape`__ состоит из одного числа и имеет вид __`(n,)`__, где __`n`__ — длина вектора. В случае двумерных векторов в __`shape`__ присутствует еще одна размерность, равная единице. 

# В большинстве случаев неважно, какое представление использовать, потому что часто срабатывает приведение типов. Но некоторые операции не работают для одномерных массивов. Например, транспонирование (о нем пойдет речь ниже):

# In[13]:

a = a.T
b = b.T


# In[14]:

print "Вектор не изменился:\n", a
print "Его размерность также не изменилась:\n", a.shape
print "Транспонированный двумерный массив:\n", b
print "Его размерность изменилась:\n", b.shape


# ## 4. Умножение матриц и столбцов

# __Напоминание теории.__ Операция __умножения__ определена для двух матриц, таких что число столбцов первой равно числу строк второй. 
# 
# Пусть матрицы $A$ и $B$ таковы, что $A \in \mathbb{R}^{n \times k}$ и $B \in \mathbb{R}^{k \times m}$. __Произведением__ матриц $A$ и $B$ называется матрица $C$, такая что $c_{ij} = \sum_{r=1}^{k} a_{ir}b_{rj}$, где $c_{ij}$ — элемент матрицы $C$, стоящий на пересечении строки с номером $i$ и столбца с номером $j$.
# 
# В `NumPy` произведение матриц вычисляется с помощью функции __`numpy.dot(a, b, ...)`__ или с помощью _метода_ __`array1.dot(array2)`__, где __`array1`__ и __`array2`__ — перемножаемые матрицы.

# In[15]:

a = np.array([[1, 0], [0, 1]])
b = np.array([[4, 1], [2, 2]])
r1 = np.dot(a, b)
r2 = a.dot(b)


# In[16]:

print "Матрица A:\n", a
print "Матрица B:\n", b
print "Результат умножения функцией:\n", r1
print "Результат умножения методом:\n", r2


# Матрицы в `NumPy` можно умножать и на векторы:

# In[17]:

c = np.array([1, 2])
r3 = b.dot(c)


# In[18]:

print "Матрица:\n", b
print "Вектор:\n", c
print "Результат умножения:\n", r3


# __Обратите внимание:__ операция __`*`__ производит над матрицами покоординатное умножение, а не матричное!

# In[19]:

r = a * b


# In[20]:

print "Матрица A:\n", a
print "Матрица B:\n", b
print "Результат покоординатного умножения через операцию *:\n", r


# Более подробно о матричном умножении в `NumPy`
# см. [документацию](http://docs.scipy.org/doc/numpy-1.10.0/reference/routines.linalg.html#matrix-and-vector-products).

# ## 5. Транспонирование матриц

# __Напоминание теории.__ __Транспонированной матрицей__ $A^{T}$ называется матрица, полученная из исходной матрицы $A$ заменой строк на столбцы. Формально: элементы матрицы $A^{T}$ определяются как $a^{T}_{ij} = a_{ji}$, где $a^{T}_{ij}$ — элемент матрицы $A^{T}$, стоящий на пересечении строки с номером $i$ и столбца с номером $j$.
# 
# В `NumPy` транспонированная матрица вычисляется с помощью функции __`numpy.transpose()`__ или с помощью _метода_ __`array.T`__, где __`array`__ — нужный двумерный массив.
# 

# In[21]:

a = np.array([[1, 2], [3, 4]])
b = np.transpose(a)
c = a.T


# In[22]:

print "Матрица:\n", a
print "Транспонирование функцией:\n", b
print "Транспонирование методом:\n",  c


# См. более подробно о 
# [numpy.transpose()](http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.transpose.html) и 
# [array.T](http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.ndarray.T.html) в `NumPy`.

# В следующих разделах активно используется модуль __`numpy.linalg`__, реализующий некоторые приложения линейной алгебры. Более подробно о функциях, описанных ниже, и различных других функциях этого модуля можно посмотреть в его [документации](http://docs.scipy.org/doc/numpy-1.10.0/reference/routines.linalg.html#linear-algebra-numpy-linalg).

# ## 6. Определитель матрицы

# __Напоминание теории.__ Для квадратных матриц существует понятие __определителя__.
# 
# Пусть $A$ — квадратная матрица. __Определителем__ (или __детерминантом__) матрицы $A \in \mathbb{R}^{n \times n}$ назовем число 
# 
# $$\det A = \sum_{\alpha_{1}, \alpha_{2}, \dots, \alpha_{n}} (-1)^{N(\alpha_{1}, \alpha_{2}, \dots, \alpha_{n})} \cdot a_{\alpha_{1} 1} \cdot \cdot \cdot a_{\alpha_{n} n},
# $$
# где $\alpha_{1}, \alpha_{2}, \dots, \alpha_{n}$ — перестановка чисел от $1$ до $n$, $N(\alpha_{1}, \alpha_{2}, \dots, \alpha_{n})$ — число инверсий в перестановке, суммирование ведется по всем возможным перестановкам длины $n$.
# 
# _Не стоит расстраиваться, если это определение понятно не до конца — в дальнейшем в таком виде оно не понадобится._
# 
# Например, для матрицы размера $2 \times 2$ получается:
# 
# $$\det \left( \begin{array}{cc} a_{11} & a_{12} \\ a_{21} & a_{22}  \end{array} \right) = a_{11} a_{22} - a_{12} a_{21}
# $$
# 
# 
# Вычисление определителя матрицы по определению требует порядка $n!$ операций, поэтому разработаны методы, которые позволяют вычислять его быстро и эффективно.
# 
# В `NumPy` определитель матрицы вычисляется с помощью функции __`numpy.linalg.det(a)`__, где __`a`__ — исходная матрица.

# In[23]:

a = np.array([[1, 2, 1], [1, 1, 4], [2, 3, 6]], dtype=np.float32)
det = np.linalg.det(a)


# In[24]:

print "Матрица:\n", a
print "Определитель:\n", det


# Рассмотрим одно интересное свойство определителя. Пусть у нас есть параллелограмм с углами в точках $(0, 0), (c,d), (a+c, b+d), (a, b)$ (углы даны в порядке обхода по часовой стрелке). Тогда площадь этого параллелограмма можно вычислить как модуль определителя матрицы $\left( \begin{array}{cc} a & c \\ b & d  \end{array} \right)$. Похожим образом можно выразить и объем параллелепипеда через определитель матрицы размера $3 \times 3$.

# ## 7. Ранг матрицы

# __Напоминание теории.__ __Рангом матрицы__ $A$ называется максимальное число линейно независимых строк (столбцов) этой матрицы.
# 
# В `NumPy` ранг матрицы вычисляется с помощью функции __`numpy.linalg.matrix_rank(M, tol=None)`__, где __`M`__ — матрица, __`tol`__ — параметр, отвечающий за некоторую точность вычисления. В простом случае можно его не задавать, и функция сама определит подходящее значение этого параметра.

# In[25]:

a = np.array([[1, 2, 3], [1, 1, 1], [2, 2, 2]])
r = np.linalg.matrix_rank(a)


# In[26]:

print "Матрица:\n", a
print "Ранг матрицы:", r


# С помощью вычисления ранга матрицы можно проверять линейную независимость системы векторов.
# 
# Допустим, у нас есть несколько векторов. Составим из них матрицу, где наши векторы будут являться строками. Понятно, что векторы линейно независимы тогда и только тогда, когда ранг полученной матрицы совпадает с числом векторов. Приведем пример:

# In[27]:

a = np.array([1, 2, 3])
b = np.array([1, 1, 1])
c = np.array([2, 3, 5])
m = np.array([a, b, c])


# In[28]:

print np.linalg.matrix_rank(m) == m.shape[0]


# ## 8. Системы линейных уравнений

# __Напоминание теории.__ __Системой линейных алгебраических уравнений__ называется система вида $Ax = b$, где $A \in \mathbb{R}^{n \times m}, x \in \mathbb{R}^{m \times 1}, b \in \mathbb{R}^{n \times 1}$. В случае квадратной невырожденной матрицы $A$ решение системы единственно.
# 
# В `NumPy` решение такой системы можно найти с помощью функции __`numpy.linalg.solve(a, b)`__, где первый аргумент — матрица $A$, второй — столбец $b$.

# In[29]:

a = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])
x = np.linalg.solve(a, b)


# In[30]:

print "Матрица A:\n", a
print "Вектор b:\n", b
print "Решение системы:\n", x


# Убедимся, что вектор __x__ действительно является решением системы:

# In[31]:

print a.dot(x)


# Бывают случаи, когда решение системы не существует. Но хотелось бы все равно "решить" такую систему. Логичным кажется искать такой вектор $x$, который минимизирует выражение $\left\Vert Ax - b\right\Vert^{2}$ — так мы приблизим выражение $Ax$ к $b$.
# 
# В `NumPy` такое псевдорешение можно искать с помощью функции __`numpy.linalg.lstsq(a, b, ...)`__, где первые два аргумента такие же, как и для функции __`numpy.linalg.solve()`__. 
# Помимо решения функция возвращает еще три значения, которые нам сейчас не понадобятся.

# In[32]:

a = np.array([[0, 1], [1, 1], [2, 1], [3, 1]])
b = np.array([-1, 0.2, 0.9, 2.1])
x, res, r, s = np.linalg.lstsq(a, b)


# In[33]:

print "Матрица A:\n", a
print "Вектор b:\n", b
print "Псевдорешение системы:\n", x


# ## 9. Обращение матриц

# __Напоминание теории.__  Для квадратных невырожденных матриц определено понятие __обратной__ матрицы. 
# 
# Пусть $A$ — квадратная невырожденная матрица. Матрица $A^{-1}$ называется __обратной матрицей__ к $A$, если 
# 
# $$AA^{-1} = A^{-1}A = I,
# $$ 
# 
# где $I$ — единичная матрица.
# 
# В `NumPy` обратные матрицы вычисляются с помощью функции __`numpy.linalg.inv(a)`__, где __`a`__ — исходная матрица.

# In[34]:

a = np.array([[1, 2, 1], [1, 1, 4], [2, 3, 6]], dtype=np.float32)
b = np.linalg.inv(a)


# In[35]:

print "Матрица A:\n", a
print "Обратная матрица к A:\n", b
print "Произведение A на обратную должна быть единичной:\n", a.dot(b)


# ## 10. Собственные числа и собственные вектора матрицы

# __Напоминание теории.__ Для квадратных матриц определены понятия __собственного вектора__ и __собственного числа__.
# 
# Пусть $A$ — квадратная матрица и $A \in \mathbb{R}^{n \times n}$. __Собственным вектором__ матрицы $A$ называется такой ненулевой вектор $x \in \mathbb{R}^{n}$, что для некоторого $\lambda \in \mathbb{R}$ выполняется равенство $Ax = \lambda x$. При этом $\lambda$ называется __собственным числом__ матрицы $A$. Собственные числа и собственные векторы матрицы играют важную роль в теории линейной алгебры и ее практических приложениях.
# 
# В `NumPy` собственные числа и собственные векторы матрицы вычисляются с помощью функции __`numpy.linalg.eig(a)`__, где __`a`__ — исходная матрица. В качестве результата эта функция выдает одномерный массив __`w`__ собственных чисел и двумерный массив __`v`__, в котором по столбцам записаны собственные вектора, так что вектор __`v[:, i]`__ соотвествует собственному числу __`w[i]`__.

# In[36]:

a = np.array([[-1, -6], [2, 6]])
w, v = np.linalg.eig(a)


# In[37]:

print "Матрица A:\n", a
print "Собственные числа:\n", w
print "Собственные векторы:\n", v


# __Обратите внимание:__ у вещественной матрицы собственные значения или собственные векторы могут быть комплексными.

# ## 11. Комплексные числа в питоне

# __Внимание: данный материал является дополнительным — его изучение не является необходимым для выполнения тестов.__

# __Напоминание теории.__ __Комплексными числами__ называются числа вида $x + iy$, где $x$ и $y$ — вещественные числа, а $i$ — мнимая единица (величина, для которой выполняется равенство $i^{2} = -1$). Множество всех комплексных чисел обозначается буквой $\mathbb{C}$ (подробнее про комплексные числа см. [википедию](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BA%D1%81%D0%BD%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE)).

# В питоне комплескные числа можно задать следующим образом (__j__ обозначает мнимую единицу):

# In[38]:

a = 3 + 2j
b = 1j


# In[39]:

print "Комплексное число a:\n", a
print "Комплексное число b:\n", b


# С комплексными числами в питоне можно производить базовые арифметические операции так же, как и с вещественными числами:

# In[40]:

c = a * a
d = a / (4 - 5j)


# In[41]:

print "Комплексное число c:\n", c
print "Комплексное число d:\n", d

